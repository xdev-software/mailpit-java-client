/*
 * Mailpit API
 * OpenAPI 2.0 documentation for [Mailpit](https://github.com/axllent/mailpit).
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package software.xdev.mailpit.api;

import com.fasterxml.jackson.core.type.TypeReference;

import software.xdev.mailpit.client.ApiException;
import software.xdev.mailpit.client.ApiClient;
import software.xdev.mailpit.client.BaseApi;
import software.xdev.mailpit.client.Configuration;
import software.xdev.mailpit.client.Pair;

import software.xdev.mailpit.model.ChaosTriggers;


import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.StringJoiner;

public class TestingApi extends BaseApi {

  public TestingApi() {
    super(Configuration.getDefaultApiClient());
  }

  public TestingApi(ApiClient apiClient) {
    super(apiClient);
  }

  /**
   * Get Chaos triggers
   * Returns the current Chaos triggers configuration. This API route will return an error if Chaos is not enabled at runtime.
   * @return ChaosTriggers
   * @throws ApiException if fails to make API call
   */
  public ChaosTriggers getChaos() throws ApiException {
    return this.getChaos(Collections.emptyMap());
  }


  /**
   * Get Chaos triggers
   * Returns the current Chaos triggers configuration. This API route will return an error if Chaos is not enabled at runtime.
   * @param additionalHeaders additionalHeaders for this call
   * @return ChaosTriggers
   * @throws ApiException if fails to make API call
   */
  public ChaosTriggers getChaos(Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/api/v1/chaos";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ChaosTriggers> localVarReturnType = new TypeReference<ChaosTriggers>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Render message HTML part
   * Renders just the message&#39;s HTML part which can be used for UI integration testing. Attached inline images are modified to link to the API provided they exist. Note that is the message does not contain a HTML part then an 404 error is returned.  The ID can be set to &#x60;latest&#x60; to return the latest message.
   * @param ID Message database ID or \&quot;latest\&quot; (required)
   * @param embed If this is route is to be embedded in an iframe, set embed to &#x60;1&#x60; in the URL to add &#x60;target&#x3D;\&quot;_blank\&quot;&#x60; and &#x60;rel&#x3D;\&quot;noreferrer noopener\&quot;&#x60; to all links.  In addition, a small script will be added to the end of the document to post (postMessage()) the height of the document back to the parent window for optional iframe height resizing.  Note that this will also *transform* the message into a full HTML document (if it isn&#39;t already), so this option is useful for viewing but not programmatic testing. (optional)
   * @return String
   * @throws ApiException if fails to make API call
   */
  public String getMessageHTMLParams(@jakarta.annotation.Nonnull String ID, @jakarta.annotation.Nullable String embed) throws ApiException {
    return this.getMessageHTMLParams(ID, embed, Collections.emptyMap());
  }


  /**
   * Render message HTML part
   * Renders just the message&#39;s HTML part which can be used for UI integration testing. Attached inline images are modified to link to the API provided they exist. Note that is the message does not contain a HTML part then an 404 error is returned.  The ID can be set to &#x60;latest&#x60; to return the latest message.
   * @param ID Message database ID or \&quot;latest\&quot; (required)
   * @param embed If this is route is to be embedded in an iframe, set embed to &#x60;1&#x60; in the URL to add &#x60;target&#x3D;\&quot;_blank\&quot;&#x60; and &#x60;rel&#x3D;\&quot;noreferrer noopener\&quot;&#x60; to all links.  In addition, a small script will be added to the end of the document to post (postMessage()) the height of the document back to the parent window for optional iframe height resizing.  Note that this will also *transform* the message into a full HTML document (if it isn&#39;t already), so this option is useful for viewing but not programmatic testing. (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return String
   * @throws ApiException if fails to make API call
   */
  public String getMessageHTMLParams(@jakarta.annotation.Nonnull String ID, @jakarta.annotation.Nullable String embed, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'ID' is set
    if (ID == null) {
      throw new ApiException(400, "Missing the required parameter 'ID' when calling getMessageHTMLParams");
    }
    
    // create path and map variables
    String localVarPath = "/view/{ID}.html"
      .replaceAll("\\{" + "ID" + "\\}", apiClient.escapeString(apiClient.parameterToString(ID)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("embed", embed));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "text/html"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<String> localVarReturnType = new TypeReference<String>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Render message text part
   * Renders just the message&#39;s text part which can be used for UI integration testing.  The ID can be set to &#x60;latest&#x60; to return the latest message.
   * @param ID Message database ID or \&quot;latest\&quot; (required)
   * @return String
   * @throws ApiException if fails to make API call
   */
  public String getMessageTextParams(@jakarta.annotation.Nonnull String ID) throws ApiException {
    return this.getMessageTextParams(ID, Collections.emptyMap());
  }


  /**
   * Render message text part
   * Renders just the message&#39;s text part which can be used for UI integration testing.  The ID can be set to &#x60;latest&#x60; to return the latest message.
   * @param ID Message database ID or \&quot;latest\&quot; (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return String
   * @throws ApiException if fails to make API call
   */
  public String getMessageTextParams(@jakarta.annotation.Nonnull String ID, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'ID' is set
    if (ID == null) {
      throw new ApiException(400, "Missing the required parameter 'ID' when calling getMessageTextParams");
    }
    
    // create path and map variables
    String localVarPath = "/view/{ID}.txt"
      .replaceAll("\\{" + "ID" + "\\}", apiClient.escapeString(apiClient.parameterToString(ID)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "text/plain"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<String> localVarReturnType = new TypeReference<String>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Set Chaos triggers
   * Set the Chaos triggers configuration and return the updated values. This API route will return an error if Chaos is not enabled at runtime.  If any triggers are omitted from the request, then those are reset to their default values with a 0% probability (ie: disabled). Setting a blank &#x60;{}&#x60; will reset all triggers to their default values.
   * @param body  (optional)
   * @return ChaosTriggers
   * @throws ApiException if fails to make API call
   */
  public ChaosTriggers setChaosParams(@jakarta.annotation.Nullable ChaosTriggers body) throws ApiException {
    return this.setChaosParams(body, Collections.emptyMap());
  }


  /**
   * Set Chaos triggers
   * Set the Chaos triggers configuration and return the updated values. This API route will return an error if Chaos is not enabled at runtime.  If any triggers are omitted from the request, then those are reset to their default values with a 0% probability (ie: disabled). Setting a blank &#x60;{}&#x60; will reset all triggers to their default values.
   * @param body  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ChaosTriggers
   * @throws ApiException if fails to make API call
   */
  public ChaosTriggers setChaosParams(@jakarta.annotation.Nullable ChaosTriggers body, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = body;
    
    // create path and map variables
    String localVarPath = "/api/v1/chaos";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<ChaosTriggers> localVarReturnType = new TypeReference<ChaosTriggers>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  @Override
  public <T> T invokeAPI(String url, String method, Object request, TypeReference<T> returnType, Map<String, String> additionalHeaders) throws ApiException {
    String localVarPath = url.replace(apiClient.getBaseURL(), "");
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarHeaderParams.putAll(additionalHeaders);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    return apiClient.invokeAPI(
      localVarPath,
        method,
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        request,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        returnType
    );
  }
}
